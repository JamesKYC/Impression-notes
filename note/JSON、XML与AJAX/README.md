# JSON、XML与AJAX

## JSON和XML数据格式

可以理解为前后台都能理解一种语言

XML 有开有关，类似于HTML标签的书写方式

```code
<person></perseon>
```

JSON 更类是于数组和对象的结合体

JSON 是纯文本

JSON 具有“自我描述性”（人类可读）

JSON 具有层级结构（值中存在值）

JSON 可通过 JavaScript 进行解析

JSON 数据可使用 AJAX 进行传输

```code
{
  person: 'feibing',
  arr: []
}
```

### 不同点

JSON没有结束标签

JSON更短

JSON读写的速度更快

JSON能够使用内建的 JavaScript eval() 方法进行解析

JSON使用数组

JSON不使用保留字

## JSON

### 优点

文件大小（体积小于XML，因此节省流量，加载速度快）

解析速度（浏览器解析XML会像HTML一样，解析成DOM树供JS来使用，而JSON是解析成对象|数组，速度要快）

查找速度（json）转换成对象之后我们只需要使用JS的语法（操作对象的方法）进行相关数据的寻找和使用，不需要使用getElementsByTagName等方法进行查找，更加简单

### 缺点

支持程度查IE7一下没有（需要引入类库）

JSON的不足之处在于，IE7的下的浏览器部支持。使用第三方类库即可解决该问题，（IE7基本退出市场）

```JS
// JSON的字符串相互转化
JSON.parse（string）;
// 将JSON的字符串转换成JS对象；
JSON，stringify（object）；
```

## 跨域

A域的前端页面访问B域是不被允许的

解决的方法

1、服务器带由访问

在A域的服务端增加一个后台接口，由A域的JS，用过AJAX访问域名的接口，之后有A域名的后台去访问B域名，在将数据放回给A域的前端

2、JSONP跨域

基本原理：动态的创建一个SCRIPT的标签，将请求的url地址设置为该标签的SRC（此方法并非AJAX访问，该方法需要前端和后端代码均进行相应的修改与实现，比较流行的框架JQ等，当中已经封装了JSONP的实现，因此，通常全段改动较少，当时后台需要多一步实现）

```js
var scriptEle = document.createElement("script");
    scriptEle.src = "http://suggestion.baidu.com/su?wd=XXX&zxmode=1&json=1&p=3&cb=update";
    // cb也就是我们需要执行的函数参数
    document.body.appendchild(scriptEle);
    function update(date){
      console.log(date)
    }
```

3、iframe跨域

动态的创建一个iframe标签，并访问url
4、HTML5的跨域

在服务器端进行适当的修改，在服务端返回的头部信息里postMessage方法

5、flash的跨域

## AJAX兼容

```js
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4 && xhr.status == 200) {
    var data = JSON.parse(xhr.responseText);
    for (var i = 0; i < data.arr.length; i++) {
      ...
      // 遍历返回的数据
    };
  };
};
xhr.open('get', 'baidu.php', true);
xhr.send;
```

xhr.onload 是火狐浏览器独有的

readyState是AJAX请求的状态

0：请求初始化（每调用open）

1：请求建立、准备好，但是未发送（已经调用open，没有调用send）

2：请求发送，服务器正在处理请求

3：数据下载到请求对象，但是响应式的数据还没有准备好，不能调用responseText

4：处理完成，对象可以使用

status是http状态码

1xx信息，服务器收到请求，需要请求者继续执行操作

2xx成功，操作被成功接收并处理

3xx重定向，需要进一步的操作以完成请求

4xx客户端错误，请求包含语法错误或无法完成请求

5xx服务器错误，服务器在处理请求的过程中发生了错误

|*|状态码|中文描述|
|-|-|-|
||100|继续。客户端应继续其请求|
||101|切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议|
|*|200|请求成功。一般用于GET与POST请求|
||201|已创建。成功请求并创建了新的资源|
||203|非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本|
||204|无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档|
||205|重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域|
||206|部分内容。服务器成功处理了部分GET请求|
||300|多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择|
|*|301|永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替|
|*|302|临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI|
||303|查看其它地址。与301类似。使用GET和POST请求查看|
|*|304|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源|
||305|使用代理。所请求的资源必须通过代理访问|
||306|已经被废弃的HTTP状态码|
||307|临时重定向。与302类似。使用GET请求重定向|
|*|400|客户端请求的语法错误，服务器无法理解|
||401|请求要求用户的身份认证|
||402|保留，将来使用|
|*|403|服务器理解请求客户端的请求，但是拒绝执行此请求|
|*|404|服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面|
||405|客户端请求中的方法被禁止|
||406|服务器无法根据客户端请求的内容特性完成请求|
||407|请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权|
||408|服务器等待客户端发送的请求时间过长，超时|
||409|服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突|
||410|客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置|
||411|服务器无法处理客户端发送的不带Content-Length的请求信息|
||412|客户端请求信息的先决条件错误|
||413|由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息|
||414|请求的URI过长（URI通常为网址），服务器无法处理|
||415|服务器无法处理请求附带的媒体格式|
||416|客户端请求的范围无效|
||417|服务器无法满足Expect的请求头信息|
||500|服务器内部错误，无法完成请求|
|*|501|服务器不支持请求的功能，无法完成请求|
||502|作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
||503|由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中|
|*|504|充当网关或代理的服务器，未及时从远端服务器获取请求|
||505|服务器不支持请求的HTTP协议的版本，无法完成处理|